<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>視線スクロールテスト</title>

  <style>
    body {
      height: 2000px;
      font-size: 18px;
      line-height: 1.6;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    .scroll-icon-container {
      position: fixed;
      bottom: 40px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 70px;
    }

    .scroll-icon {
      width: 60px;
      height: 60px;
      background-color: rgba(0, 255, 0, 0.2);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
    }

    #page-content {
      margin-top: 100px;
      font-size: 32px;
    }

    #page-number {
      position: fixed;
      bottom: 20px;
      right: 20px;
      font-size: 18px;
    }

    #gaze-cursor {
      position: fixed;
      width: 30px;
      height: 30px;
      background-color: transparent;
      border: 3px solid red;
      border-radius: 50%;
      pointer-events: none;
      transform: translate(-50%, -50%);
      z-index: 9999;
      display: none;
      align-items: center;
      justify-content: center;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <div id="gaze-cursor"></div>

  <div class="content">
    <h1>視線スクロールテスト</h1>
    <p id="page-content">{{ page_text }}</p>
    <a href="/distance_travelled">視線移動距離のページを見る</a>
  </div>

  <div id="page-number">Page: 1</div>

  <div class="scroll-icon-container">
    <div id="scroll-icon" class="scroll-icon">⬆️</div>
    <div id="scroll-icon-down" class="scroll-icon">⬇️</div>
  </div>

  <script>
    let hasScrolled = false;
    let lastGazeX = 0;
    let hasScrolledX = false;
    let hasScrolledY = false;
    let scrollBackStartTime = null;
    let gazeTimer = null;
    let gazeTimerDown = null;

    let lastGazePosition = null;
    let gazeHoldStartTime = null;
    const HOLD_DURATION = 500;

    function checkGazeOnIcon(x, y) {
      const icon = document.getElementById('scroll-icon');
      const rect = icon.getBoundingClientRect();
      const screenX = window.innerWidth * x;
      const screenY = window.innerHeight * y;

      const insideIcon = screenX >= rect.left && screenX <= rect.right &&
                         screenY >= rect.top && screenY <= rect.bottom;

      if (insideIcon) {
        if (!gazeTimer) {
          gazeTimer = setTimeout(() => {
            const currentScroll = window.scrollY;
            const scrollAmount = window.innerHeight / 2;
            const targetPosition = Math.max(0, currentScroll - scrollAmount);

            window.scrollTo({ top: targetPosition, behavior: 'smooth' });
            gazeTimer = null;
          }, 1000);
        }
      } else {
        if (gazeTimer) {
          clearTimeout(gazeTimer);
          gazeTimer = null;
        }
      }
    }

    function checkGazeOnDownIcon(x, y) {
      const icon = document.getElementById('scroll-icon-down');
      const rect = icon.getBoundingClientRect();
      const screenX = window.innerWidth * x;
      const screenY = window.innerHeight * y;

      const insideIcon = screenX >= rect.left && screenX <= rect.right &&
                         screenY >= rect.top && screenY <= rect.bottom;

      if (insideIcon) {
        if (!gazeTimerDown) {
          gazeTimerDown = setTimeout(() => {
            scrollDownByHalfScreen();
            gazeTimerDown = null;
          }, 1000);
        }
      } else {
        if (gazeTimerDown) {
          clearTimeout(gazeTimerDown);
          gazeTimerDown = null;
        }
      }
    }

    function scrollDownByHalfScreen() {
      const currentScroll = window.scrollY;
      const scrollAmount = window.innerHeight / 2;
      const targetPosition = Math.min(document.body.scrollHeight, currentScroll + scrollAmount);
      window.scrollTo({ top: targetPosition, behavior: 'smooth' });
    }

    function scrollHalfDownSmoothly(startX, startY) {
        const scrollAmount = window.innerHeight / 2;
        const startScroll = window.scrollY;
        const targetScroll = Math.min(document.body.scrollHeight, startScroll + scrollAmount);
        const startTime = performance.now();
        const duration = 1000;

        const cursor = document.getElementById('gaze-cursor');
        const startCursorY = window.innerHeight * startY;
        const targetCursorY = startCursorY + scrollAmount; // ✅ 下へ
        const startCursorX = window.innerWidth * startX;   // ✅ X固定

        function animate(time) {
            const elapsed = time - startTime;
            const progress = Math.min(elapsed / duration, 1);
            const ease = progress < 0.5
            ? 2 * progress * progress
            : -1 + (4 - 2 * progress) * progress;

            const newScroll = startScroll + (targetScroll - startScroll) * ease;
            const newCursorY = startCursorY + (targetCursorY - startCursorY) * ease;

            window.scrollTo(0, newScroll);
            cursor.style.top = `${newCursorY}px`;
            cursor.style.left = `${startCursorX}px`;
            cursor.style.display = 'flex';

            if (progress < 1) {
            requestAnimationFrame(animate);
            } else {
            setTimeout(() => {
                cursor.style.display = 'none';
            }, 500);
            }
        }

    requestAnimationFrame(animate);
    }


    function isSamePosition(pos1, pos2) {
      const THRESHOLD = 0.01;
      return Math.abs(pos1.x - pos2.x) < THRESHOLD && Math.abs(pos1.y - pos2.y) < THRESHOLD;
    }

    function getGazeData() {
      fetch('/gaze_data')
        .then(response => response.json())
        .then(data => {
          const x = data.x;
          const y = data.y;
          const currentTime = Date.now();

          const currentPosition = { x, y };
          const gazeCursor = document.getElementById('gaze-cursor');

          if (lastGazePosition && isSamePosition(currentPosition, lastGazePosition)) {
            if (!gazeHoldStartTime) {
              gazeHoldStartTime = currentTime;
            } else if (currentTime - gazeHoldStartTime >= HOLD_DURATION) {
              scrollHalfDownSmoothly(x, y);
              gazeHoldStartTime = null;
            }
          } else {
            gazeHoldStartTime = null;
            gazeCursor.style.display = 'none';
          }

          gazeCursor.style.left = `${window.innerWidth * x}px`;
          gazeCursor.style.top = `${window.innerHeight * y}px`;

          if (x > 0.8 && !hasScrolledX && lastGazeX < x) {
            window.scrollBy(0, 30);
            hasScrolledX = true;
          } else if (x < 0.5) {
            hasScrolledX = false;
          }

          if (y > 0.8 && !hasScrolledY && lastGazeX < y) {
            scrollDownByHalfScreen();
            hasScrolledY = true;
          } else if (y < 0.5) {
            hasScrolledY = false;
          }

          if (x < 0.2 && y < 0.5) {
            if (!scrollBackStartTime) {
              scrollBackStartTime = currentTime;
            } else if (currentTime - scrollBackStartTime > 500) {
              window.scrollTo({ top: 0, behavior: 'smooth' });
              scrollBackStartTime = null;
            }
          } else {
            scrollBackStartTime = null;
          }

          checkGazeOnIcon(x, y);
          checkGazeOnDownIcon(x, y);

          lastGazeX = x;
          lastGazePosition = currentPosition;
        })
        .catch(error => console.error("視線データ取得エラー:", error));
    }

    setInterval(getGazeData, 100);
  </script>
</body>
</html>
